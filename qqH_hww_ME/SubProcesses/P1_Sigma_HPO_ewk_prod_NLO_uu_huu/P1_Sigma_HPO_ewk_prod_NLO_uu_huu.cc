// 
// *  This file was automatically generated by MoMEMta-MaGMEE,
// *  A MadGraph Matrix Element Exporter plugin for MoMEMta.
// *
// *  It is subject to MoMEMta-MaGMEE's license and copyright:
// *
// *  Copyright (C) 2016  Universite catholique de Louvain (UCL), Belgium
// *
// *  This program is free software: you can redistribute it and/or modify
// *  it under the terms of the GNU General Public License as published by
// *  the Free Software Foundation, either version 3 of the License, or
// *  (at your option) any later version.
// *
// *  This program is distributed in the hope that it will be useful,
// *  but WITHOUT ANY WARRANTY; without even the implied warranty of
// *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// *  GNU General Public License for more details.
// *
// *  You should have received a copy of the GNU General Public License
// *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
// 

#include <string> 
#include <utility> 
#include <vector> 
#include <map> 

#include <P1_Sigma_HPO_ewk_prod_NLO_uu_huu.h> 
#include <HelAmps_HPO_ewk_prod_NLO.h> 

#include <momemta/ParameterSet.h> 
#include <momemta/SLHAReader.h> 

namespace qqH_hww_ME_HPO_ewk_prod_NLO 
{

//==========================================================================
// Class member functions for calculating the matrix elements for
// Process: u u > h u u HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c c > h c c HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: d d > h d d HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: s s > h s s HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u~ u~ > h u~ u~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c~ c~ > h c~ c~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: d~ d~ > h d~ d~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: s~ s~ > h s~ s~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u d > h u d HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c s > h c s HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u s > h u s HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c d > h c d HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u~ d~ > h u~ d~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c~ s~ > h c~ s~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u~ s~ > h u~ s~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c~ d~ > h c~ d~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u c > h u c HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u u~ > h u u~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u c~ > h u c~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c u~ > h c u~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c c~ > h c c~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u d~ > h u d~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u s~ > h u s~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c d~ > h c d~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c s~ > h c s~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: d s > h d s HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: d u~ > h d u~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: d c~ > h d c~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: s u~ > h s u~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: s c~ > h s c~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: d d~ > h d d~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: d s~ > h d s~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: s d~ > h s d~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: s s~ > h s s~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u~ c~ > h u~ c~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: d~ s~ > h d~ s~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u d > h u s HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u s > h c s HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u d > h c d HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c d > h c s HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u d > h c s HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u s > h u d HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c s > h u s HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u s > h c d HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c d > h u s HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u u~ > h d d~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u c~ > h d s~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c u~ > h s d~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c c~ > h s s~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u u~ > h d s~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c u~ > h s s~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u u~ > h s d~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u c~ > h s s~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u u~ > h s s~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u c~ > h d d~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c c~ > h s d~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u c~ > h s d~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c d > h u d HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c s > h c d HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c s > h u d HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c u~ > h d d~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c c~ > h d s~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c u~ > h d s~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c c~ > h d d~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: d d~ > h u u~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: d s~ > h u c~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: s d~ > h c u~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: s s~ > h c c~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: d d~ > h u c~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: s d~ > h c c~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: d d~ > h c u~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: d s~ > h c c~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: d d~ > h c c~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: d s~ > h u u~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: s s~ > h c u~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: d s~ > h c u~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: s d~ > h u u~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: s s~ > h u c~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: s d~ > h u c~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: s s~ > h u u~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u~ d~ > h u~ s~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u~ s~ > h c~ s~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u~ d~ > h c~ d~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c~ d~ > h c~ s~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u~ d~ > h c~ s~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u~ s~ > h u~ d~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c~ s~ > h u~ s~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: u~ s~ > h c~ d~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c~ d~ > h u~ s~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c~ d~ > h u~ d~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c~ s~ > h c~ d~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1
// Process: c~ s~ > h u~ d~ HPO<=1 QCD=0 YUK=0 $$ a z w+ w- @1

//--------------------------------------------------------------------------

// Initialize process.

P1_Sigma_HPO_ewk_prod_NLO_uu_huu::P1_Sigma_HPO_ewk_prod_NLO_uu_huu(const
    ParameterSet& configuration)
{

  std::string param_card = configuration.get < std::string > ("card"); 
  params.reset(new Parameters_HPO_ewk_prod_NLO(SLHA::Reader(param_card))); 

  // Set external particle masses for this matrix element
  mME.push_back(std::ref(params->ZERO)); 
  mME.push_back(std::ref(params->ZERO)); 
  mME.push_back(std::ref(params->mdl_MH)); 
  mME.push_back(std::ref(params->ZERO)); 
  mME.push_back(std::ref(params->ZERO)); 

  mapFinalStates[{25, -4, -3}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uxdx_hcxsx, 
      true, 
      {
        std::make_pair(-2, -1)
      }, 
      16, 
      36
    }
  }; 
  mapFinalStates[{25, -2, -2}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uxux_huxux, 
      false, 
      {
        std::make_pair(-2, -2), std::make_pair(-4, -4)
      }, 
      16, 
      72
    }
  }; 
  mapFinalStates[{25, 1, 3}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ds_hds, 
      true, 
      {
        std::make_pair(1, 3)
      }, 
      16, 
      36
    }
  }; 
  mapFinalStates[{25, -4, -1}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_cxdx_hcxdx, 
      true, 
      {
        std::make_pair(-4, -1)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uxdx_hcxdx, 
      true, 
      {
        std::make_pair(-2, -1), std::make_pair(-4, -1)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uxsx_hcxdx, 
      true, 
      {
        std::make_pair(-2, -3), std::make_pair(-4, -1)
      }, 
      16, 
      36
    }
  }; 
  mapFinalStates[{25, 2, 1}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ud_hud, 
      true, 
      {
        std::make_pair(2, 1), std::make_pair(4, 3)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_us_hud, 
      true, 
      {
        std::make_pair(2, 3), std::make_pair(4, 3)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_cd_hud, 
      true, 
      {
        std::make_pair(4, 1), std::make_pair(4, 3)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_cs_hud, 
      true, 
      {
        std::make_pair(4, 3)
      }, 
      16, 
      36
    }
  }; 
  mapFinalStates[{25, -2, -4}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uxcx_huxcx, 
      true, 
      {
        std::make_pair(-2, -4)
      }, 
      16, 
      36
    }
  }; 
  mapFinalStates[{25, 1, 1}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_dd_hdd, 
      false, 
      {
        std::make_pair(1, 1), std::make_pair(3, 3)
      }, 
      16, 
      72
    }
  }; 
  mapFinalStates[{25, -1, -1}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_dxdx_hdxdx, 
      false, 
      {
        std::make_pair(-1, -1), std::make_pair(-3, -3)
      }, 
      16, 
      72
    }
  }; 
  mapFinalStates[{25, 2, -1}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_udx_hudx, 
      true, 
      {
        std::make_pair(2, -1), std::make_pair(2, -3), std::make_pair(4, -1),
            std::make_pair(4, -3)
      }, 
      16, 
      36
    }
  }; 
  mapFinalStates[{25, 4, -4}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ddx_hccx, 
      true, 
      {
        std::make_pair(1, -1)
      }, 
      16, 
      36
    }
  }; 
  mapFinalStates[{25, 3, -1}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uux_hsdx, 
      true, 
      {
        std::make_pair(2, -2), std::make_pair(2, -4)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ucx_hsdx, 
      true, 
      {
        std::make_pair(2, -4)
      }, 
      16, 
      36
    }
  }; 
  mapFinalStates[{25, 2, 3}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_us_hus, 
      true, 
      {
        std::make_pair(2, 3)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ud_hus, 
      true, 
      {
        std::make_pair(2, 1), std::make_pair(2, 3)
      }, 
      16, 
      36
    }
  }; 
  mapFinalStates[{25, -1, -3}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_dxsx_hdxsx, 
      true, 
      {
        std::make_pair(-1, -3)
      }, 
      16, 
      36
    }
  }; 
  mapFinalStates[{25, 1, -2}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_dux_hdux, 
      true, 
      {
        std::make_pair(1, -2), std::make_pair(1, -4), std::make_pair(3, -2),
            std::make_pair(3, -4)
      }, 
      16, 
      36
    }
  }; 
  mapFinalStates[{25, -2, -3}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uxsx_huxsx, 
      true, 
      {
        std::make_pair(-2, -3)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uxdx_huxsx, 
      true, 
      {
        std::make_pair(-2, -1), std::make_pair(-2, -3)
      }, 
      16, 
      36
    }
  }; 
  mapFinalStates[{25, 4, 3}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ud_hcs, 
      true, 
      {
        std::make_pair(2, 1)
      }, 
      16, 
      36
    }
  }; 
  mapFinalStates[{25, 3, -3}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uux_hssx, 
      true, 
      {
        std::make_pair(2, -2)
      }, 
      16, 
      36
    }
  }; 
  mapFinalStates[{25, -2, -1}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uxdx_huxdx, 
      true, 
      {
        std::make_pair(-2, -1), std::make_pair(-4, -3)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uxsx_huxdx, 
      true, 
      {
        std::make_pair(-2, -3), std::make_pair(-4, -3)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_cxdx_huxdx, 
      true, 
      {
        std::make_pair(-4, -1), std::make_pair(-4, -3)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_cxsx_huxdx, 
      true, 
      {
        std::make_pair(-4, -3)
      }, 
      16, 
      36
    }
  }; 
  mapFinalStates[{25, 4, 1}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_cd_hcd, 
      true, 
      {
        std::make_pair(4, 1)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ud_hcd, 
      true, 
      {
        std::make_pair(2, 1), std::make_pair(4, 1)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_us_hcd, 
      true, 
      {
        std::make_pair(2, 3), std::make_pair(4, 1)
      }, 
      16, 
      36
    }
  }; 
  mapFinalStates[{25, 2, 4}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uc_huc, 
      true, 
      {
        std::make_pair(2, 4)
      }, 
      16, 
      36
    }
  }; 
  mapFinalStates[{25, 1, -3}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uux_hdsx, 
      true, 
      {
        std::make_pair(2, -2), std::make_pair(4, -2)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_cux_hdsx, 
      true, 
      {
        std::make_pair(4, -2)
      }, 
      16, 
      36
    }
  }; 
  mapFinalStates[{25, 2, 2}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uu_huu, 
      false, 
      {
        std::make_pair(2, 2), std::make_pair(4, 4)
      }, 
      16, 
      72
    }
  }; 
  mapFinalStates[{25, 2, -4}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ddx_hucx, 
      true, 
      {
        std::make_pair(1, -1), std::make_pair(3, -1)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_sdx_hucx, 
      true, 
      {
        std::make_pair(3, -1)
      }, 
      16, 
      36
    }
  }; 
  mapFinalStates[{25, 2, -2}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uux_huux, 
      true, 
      {
        std::make_pair(2, -2), std::make_pair(2, -4), std::make_pair(4, -2),
            std::make_pair(4, -4)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ddx_huux, 
      true, 
      {
        std::make_pair(1, -1), std::make_pair(1, -3), std::make_pair(3, -1),
            std::make_pair(3, -3)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_dsx_huux, 
      true, 
      {
        std::make_pair(1, -3), std::make_pair(3, -3)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_sdx_huux, 
      true, 
      {
        std::make_pair(3, -1), std::make_pair(3, -3)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ssx_huux, 
      true, 
      {
        std::make_pair(3, -3)
      }, 
      16, 
      36
    }
  }; 
  mapFinalStates[{25, 4, -2}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ddx_hcux, 
      true, 
      {
        std::make_pair(1, -1), std::make_pair(1, -3)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_dsx_hcux, 
      true, 
      {
        std::make_pair(1, -3)
      }, 
      16, 
      36
    }
  }; 
  mapFinalStates[{25, 1, -1}] = 
  {
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ddx_hddx, 
      true, 
      {
        std::make_pair(1, -1), std::make_pair(1, -3), std::make_pair(3, -1),
            std::make_pair(3, -3)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uux_hddx, 
      true, 
      {
        std::make_pair(2, -2), std::make_pair(2, -4), std::make_pair(4, -2),
            std::make_pair(4, -4)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ucx_hddx, 
      true, 
      {
        std::make_pair(2, -4), std::make_pair(4, -4)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_cux_hddx, 
      true, 
      {
        std::make_pair(4, -2), std::make_pair(4, -4)
      }, 
      16, 
      36
    }
    , 
    {
      &P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ccx_hddx, 
      true, 
      {
        std::make_pair(4, -4)
      }, 
      16, 
      36
    }
  }; 

}

void P1_Sigma_HPO_ewk_prod_NLO_uu_huu::resetHelicities() 
{
  for (auto& finalState: mapFinalStates)
  {
    for (auto& subProcess: finalState.second)
    {
      subProcess.resetHelicities(); 
    }
  }
}


//--------------------------------------------------------------------------
// Evaluate |M|^2, return a map of final states

std::map < std::pair < int, int > , double >
    P1_Sigma_HPO_ewk_prod_NLO_uu_huu::compute(const std::pair <
    std::vector<double> , std::vector<double> > &initialMomenta, const
    std::vector < std::pair < int, std::vector<double> > > &finalState)
{

  // Set initial particle momenta
  momenta[0] = (double * ) (&initialMomenta.first[0]); 
  momenta[1] = (double * ) (&initialMomenta.second[0]); 

  // Suppose final particles are passed in the "correct" order
  std::vector<int> selectedFinalState(5 - 2); 
  for (size_t index = 0; index < (5 - 2); index++ )
  {
    selectedFinalState[index] = finalState[index].first; 
    momenta[index + 2] = (double * ) (&finalState[index].second[0]); 
  }

  // Set the event specific parameters
  params->updateParameters(); 
  params->updateCouplings(); 

  // Initialise result object
  std::map < std::pair < int, int > , double > result; 

  // Define permutation
  int perm[5]; 
  for(int i = 0; i < 5; i++ )
  {
    perm[i] = i; 
  }

  for(auto &me: mapFinalStates[selectedFinalState])
  {

    double me_sum = 0; 
    double me_mirror_sum = 0; 

    for(int ihel = 0; ihel < 16; ihel++ )
    {

      if(me.goodHel[ihel])
      {

        double sum = 0.; 
        calculate_wavefunctions(perm, helicities[ihel]); 
        double meTemp = me.callback( * this); 
        sum += meTemp; 
        me_sum += meTemp/me.denominator; 

        if(me.hasMirrorProcess)
        {
          perm[0] = 1; 
          perm[1] = 0; 
          // Calculate wavefunctions
          calculate_wavefunctions(perm, helicities[ihel]); 
          // Mirror back
          perm[0] = 0; 
          perm[1] = 1; 
          meTemp = me.callback( * this); 
          sum += meTemp; 
          me_mirror_sum += meTemp/me.denominator; 
        }

        if( !sum)
          me.goodHel[ihel] = false; 
      }
    }

    for (auto const &initialState: me.initialStates)
    {
      result[initialState] = me_sum; 
      if (me.hasMirrorProcess)
        result[std::make_pair(initialState.second, initialState.first)] =
            me_mirror_sum;
    }
  }


  return result; 
}

//==========================================================================
// Private class member functions

//--------------------------------------------------------------------------
// Evaluate |M|^2 for each subprocess

void P1_Sigma_HPO_ewk_prod_NLO_uu_huu::calculate_wavefunctions(const int
    perm[], const int hel[])
{
  // Calculate wavefunctions for all processes
  static std::complex<double> w[79][18]; 

  // Calculate all wavefunctions
  ixxxxx(&momenta[perm[0]][0], mME[0], hel[0], +1, w[0]); 
  ixxxxx(&momenta[perm[1]][0], mME[1], hel[1], +1, w[1]); 
  sxxxxx(&momenta[perm[2]][0], +1, w[2]); 
  oxxxxx(&momenta[perm[3]][0], mME[3], hel[3], +1, w[3]); 
  oxxxxx(&momenta[perm[4]][0], mME[4], hel[4], +1, w[4]); 
  FFV1P0_3(w[0], w[3], params->GC_2, params->ZERO, params->ZERO, w[5]); 
  FFV1P0_3(w[1], w[4], params->GC_2, params->ZERO, params->ZERO, w[6]); 
  FFV2_3_3(w[1], w[4], params->GC_39, params->GC_40, params->mdl_MZ,
      params->mdl_WZ, w[7]);
  FFV2_3_3(w[0], w[3], params->GC_39, params->GC_40, params->mdl_MZ,
      params->mdl_WZ, w[8]);
  FFV1P0_3(w[0], w[4], params->GC_2, params->ZERO, params->ZERO, w[9]); 
  FFV1P0_3(w[1], w[3], params->GC_2, params->ZERO, params->ZERO, w[10]); 
  FFV2_3_3(w[1], w[3], params->GC_39, params->GC_40, params->mdl_MZ,
      params->mdl_WZ, w[11]);
  FFV2_3_3(w[0], w[4], params->GC_39, params->GC_40, params->mdl_MZ,
      params->mdl_WZ, w[12]);
  FFVS1_2_3(w[0], w[3], w[2], params->GC_19, params->GC_20, params->mdl_MZ,
      params->mdl_WZ, w[13]);
  FFVS1_2_3(w[0], w[4], w[2], params->GC_19, params->GC_20, params->mdl_MZ,
      params->mdl_WZ, w[14]);
  FFV1P0_3(w[0], w[3], params->GC_1, params->ZERO, params->ZERO, w[15]); 
  FFV1P0_3(w[1], w[4], params->GC_1, params->ZERO, params->ZERO, w[16]); 
  FFV2_3_3(w[1], w[4], params->GC_31, params->GC_32, params->mdl_MZ,
      params->mdl_WZ, w[17]);
  FFV2_3_3(w[0], w[3], params->GC_31, params->GC_32, params->mdl_MZ,
      params->mdl_WZ, w[18]);
  FFV1P0_3(w[0], w[4], params->GC_1, params->ZERO, params->ZERO, w[19]); 
  FFV1P0_3(w[1], w[3], params->GC_1, params->ZERO, params->ZERO, w[20]); 
  FFV2_3_3(w[1], w[3], params->GC_31, params->GC_32, params->mdl_MZ,
      params->mdl_WZ, w[21]);
  FFV2_3_3(w[0], w[4], params->GC_31, params->GC_32, params->mdl_MZ,
      params->mdl_WZ, w[22]);
  FFVS1_2_3(w[0], w[3], w[2], params->GC_11, params->GC_12, params->mdl_MZ,
      params->mdl_WZ, w[23]);
  FFVS1_2_3(w[0], w[4], w[2], params->GC_11, params->GC_12, params->mdl_MZ,
      params->mdl_WZ, w[24]);
  oxxxxx(&momenta[perm[0]][0], mME[0], hel[0], -1, w[25]); 
  oxxxxx(&momenta[perm[1]][0], mME[1], hel[1], -1, w[26]); 
  ixxxxx(&momenta[perm[3]][0], mME[3], hel[3], -1, w[27]); 
  ixxxxx(&momenta[perm[4]][0], mME[4], hel[4], -1, w[28]); 
  FFV1P0_3(w[27], w[25], params->GC_2, params->ZERO, params->ZERO, w[29]); 
  FFV1P0_3(w[28], w[26], params->GC_2, params->ZERO, params->ZERO, w[30]); 
  FFV2_3_3(w[28], w[26], params->GC_39, params->GC_40, params->mdl_MZ,
      params->mdl_WZ, w[31]);
  FFV2_3_3(w[27], w[25], params->GC_39, params->GC_40, params->mdl_MZ,
      params->mdl_WZ, w[32]);
  FFV1P0_3(w[28], w[25], params->GC_2, params->ZERO, params->ZERO, w[33]); 
  FFV1P0_3(w[27], w[26], params->GC_2, params->ZERO, params->ZERO, w[34]); 
  FFV2_3_3(w[27], w[26], params->GC_39, params->GC_40, params->mdl_MZ,
      params->mdl_WZ, w[35]);
  FFV2_3_3(w[28], w[25], params->GC_39, params->GC_40, params->mdl_MZ,
      params->mdl_WZ, w[36]);
  FFVS1_2_3(w[27], w[25], w[2], params->GC_19, params->GC_20, params->mdl_MZ,
      params->mdl_WZ, w[37]);
  FFVS1_2_3(w[28], w[25], w[2], params->GC_19, params->GC_20, params->mdl_MZ,
      params->mdl_WZ, w[38]);
  FFV1P0_3(w[27], w[25], params->GC_1, params->ZERO, params->ZERO, w[39]); 
  FFV1P0_3(w[28], w[26], params->GC_1, params->ZERO, params->ZERO, w[40]); 
  FFV2_3_3(w[28], w[26], params->GC_31, params->GC_32, params->mdl_MZ,
      params->mdl_WZ, w[41]);
  FFV2_3_3(w[27], w[25], params->GC_31, params->GC_32, params->mdl_MZ,
      params->mdl_WZ, w[42]);
  FFV1P0_3(w[28], w[25], params->GC_1, params->ZERO, params->ZERO, w[43]); 
  FFV1P0_3(w[27], w[26], params->GC_1, params->ZERO, params->ZERO, w[44]); 
  FFV2_3_3(w[27], w[26], params->GC_31, params->GC_32, params->mdl_MZ,
      params->mdl_WZ, w[45]);
  FFV2_3_3(w[28], w[25], params->GC_31, params->GC_32, params->mdl_MZ,
      params->mdl_WZ, w[46]);
  FFVS1_2_3(w[27], w[25], w[2], params->GC_11, params->GC_12, params->mdl_MZ,
      params->mdl_WZ, w[47]);
  FFVS1_2_3(w[28], w[25], w[2], params->GC_11, params->GC_12, params->mdl_MZ,
      params->mdl_WZ, w[48]);
  FFV2_3(w[0], w[4], params->GC_42, params->mdl_MW, params->mdl_WW, w[49]); 
  FFV2_3(w[1], w[3], params->GC_42, params->mdl_MW, params->mdl_WW, w[50]); 
  FFVS1_3(w[0], w[4], w[2], params->GC_130, params->mdl_MW, params->mdl_WW,
      w[51]);
  FFV2_3(w[0], w[4], params->GC_119, params->mdl_MW, params->mdl_WW, w[52]); 
  FFV2_3(w[1], w[3], params->GC_119, params->mdl_MW, params->mdl_WW, w[53]); 
  FFVS1_3(w[0], w[4], w[2], params->GC_134, params->mdl_MW, params->mdl_WW,
      w[54]);
  FFV2_3(w[0], w[4], params->GC_118, params->mdl_MW, params->mdl_WW, w[55]); 
  FFV2_3(w[1], w[3], params->GC_118, params->mdl_MW, params->mdl_WW, w[56]); 
  FFVS1_3(w[0], w[4], w[2], params->GC_131, params->mdl_MW, params->mdl_WW,
      w[57]);
  FFV2_3(w[28], w[25], params->GC_42, params->mdl_MW, params->mdl_WW, w[58]); 
  FFV2_3(w[27], w[26], params->GC_42, params->mdl_MW, params->mdl_WW, w[59]); 
  FFVS1_3(w[28], w[25], w[2], params->GC_129, params->mdl_MW, params->mdl_WW,
      w[60]);
  FFV2_3(w[28], w[25], params->GC_119, params->mdl_MW, params->mdl_WW, w[61]); 
  FFV2_3(w[27], w[26], params->GC_119, params->mdl_MW, params->mdl_WW, w[62]); 
  FFVS1_3(w[28], w[25], w[2], params->GC_132, params->mdl_MW, params->mdl_WW,
      w[63]);
  FFV2_3(w[28], w[25], params->GC_118, params->mdl_MW, params->mdl_WW, w[64]); 
  FFV2_3(w[27], w[26], params->GC_118, params->mdl_MW, params->mdl_WW, w[65]); 
  FFVS1_3(w[28], w[25], w[2], params->GC_133, params->mdl_MW, params->mdl_WW,
      w[66]);
  FFV2_3(w[0], w[3], params->GC_42, params->mdl_MW, params->mdl_WW, w[67]); 
  FFV2_3(w[28], w[26], params->GC_42, params->mdl_MW, params->mdl_WW, w[68]); 
  FFVS1_3(w[0], w[3], w[2], params->GC_130, params->mdl_MW, params->mdl_WW,
      w[69]);
  FFV2_3(w[28], w[26], params->GC_119, params->mdl_MW, params->mdl_WW, w[70]); 
  FFV2_3(w[0], w[3], params->GC_119, params->mdl_MW, params->mdl_WW, w[71]); 
  FFVS1_3(w[0], w[3], w[2], params->GC_134, params->mdl_MW, params->mdl_WW,
      w[72]);
  FFV2_3(w[28], w[26], params->GC_118, params->mdl_MW, params->mdl_WW, w[73]); 
  FFV2_3(w[0], w[3], params->GC_118, params->mdl_MW, params->mdl_WW, w[74]); 
  FFVS1_3(w[0], w[3], w[2], params->GC_131, params->mdl_MW, params->mdl_WW,
      w[75]);
  FFVS1_3(w[0], w[3], w[2], params->GC_129, params->mdl_MW, params->mdl_WW,
      w[76]);
  FFVS1_3(w[0], w[3], w[2], params->GC_133, params->mdl_MW, params->mdl_WW,
      w[77]);
  FFVS1_3(w[0], w[3], w[2], params->GC_132, params->mdl_MW, params->mdl_WW,
      w[78]);

  // Calculate all amplitudes
  // Amplitude(s) for diagram number 0
  VVS3_5_0(w[5], w[6], w[2], params->GC_26, params->GC_24, amp[0]); 
  VVS1_5_0(w[5], w[7], w[2], params->GC_27, params->GC_25, amp[1]); 
  VVS1_5_0(w[6], w[8], w[2], params->GC_27, params->GC_25, amp[2]); 
  VVS3_4_5_0(w[8], w[7], w[2], params->GC_23, params->GC_8, params->GC_22,
      amp[3]);
  FFVS1_2_0(w[1], w[4], w[8], w[2], params->GC_19, params->GC_20, amp[4]); 
  VVS3_5_0(w[9], w[10], w[2], params->GC_26, params->GC_24, amp[5]); 
  VVS1_5_0(w[9], w[11], w[2], params->GC_27, params->GC_25, amp[6]); 
  VVS1_5_0(w[10], w[12], w[2], params->GC_27, params->GC_25, amp[7]); 
  VVS3_4_5_0(w[12], w[11], w[2], params->GC_23, params->GC_8, params->GC_22,
      amp[8]);
  FFVS1_2_0(w[1], w[3], w[12], w[2], params->GC_19, params->GC_20, amp[9]); 
  FFV2_3_0(w[1], w[4], w[13], params->GC_39, params->GC_40, amp[10]); 
  FFV2_3_0(w[1], w[3], w[14], params->GC_39, params->GC_40, amp[11]); 
  VVS3_5_0(w[15], w[16], w[2], params->GC_26, params->GC_24, amp[12]); 
  VVS1_5_0(w[15], w[17], w[2], params->GC_27, params->GC_25, amp[13]); 
  VVS1_5_0(w[16], w[18], w[2], params->GC_27, params->GC_25, amp[14]); 
  VVS3_4_5_0(w[18], w[17], w[2], params->GC_23, params->GC_8, params->GC_22,
      amp[15]);
  FFVS1_2_0(w[1], w[4], w[18], w[2], params->GC_11, params->GC_12, amp[16]); 
  VVS3_5_0(w[19], w[20], w[2], params->GC_26, params->GC_24, amp[17]); 
  VVS1_5_0(w[19], w[21], w[2], params->GC_27, params->GC_25, amp[18]); 
  VVS1_5_0(w[20], w[22], w[2], params->GC_27, params->GC_25, amp[19]); 
  VVS3_4_5_0(w[22], w[21], w[2], params->GC_23, params->GC_8, params->GC_22,
      amp[20]);
  FFVS1_2_0(w[1], w[3], w[22], w[2], params->GC_11, params->GC_12, amp[21]); 
  FFV2_3_0(w[1], w[4], w[23], params->GC_31, params->GC_32, amp[22]); 
  FFV2_3_0(w[1], w[3], w[24], params->GC_31, params->GC_32, amp[23]); 
  VVS3_5_0(w[29], w[30], w[2], params->GC_26, params->GC_24, amp[24]); 
  VVS1_5_0(w[29], w[31], w[2], params->GC_27, params->GC_25, amp[25]); 
  VVS1_5_0(w[30], w[32], w[2], params->GC_27, params->GC_25, amp[26]); 
  VVS3_4_5_0(w[32], w[31], w[2], params->GC_23, params->GC_8, params->GC_22,
      amp[27]);
  FFVS1_2_0(w[28], w[26], w[32], w[2], params->GC_19, params->GC_20, amp[28]); 
  VVS3_5_0(w[33], w[34], w[2], params->GC_26, params->GC_24, amp[29]); 
  VVS1_5_0(w[33], w[35], w[2], params->GC_27, params->GC_25, amp[30]); 
  VVS1_5_0(w[34], w[36], w[2], params->GC_27, params->GC_25, amp[31]); 
  VVS3_4_5_0(w[36], w[35], w[2], params->GC_23, params->GC_8, params->GC_22,
      amp[32]);
  FFVS1_2_0(w[27], w[26], w[36], w[2], params->GC_19, params->GC_20, amp[33]); 
  FFV2_3_0(w[28], w[26], w[37], params->GC_39, params->GC_40, amp[34]); 
  FFV2_3_0(w[27], w[26], w[38], params->GC_39, params->GC_40, amp[35]); 
  VVS3_5_0(w[39], w[40], w[2], params->GC_26, params->GC_24, amp[36]); 
  VVS1_5_0(w[39], w[41], w[2], params->GC_27, params->GC_25, amp[37]); 
  VVS1_5_0(w[40], w[42], w[2], params->GC_27, params->GC_25, amp[38]); 
  VVS3_4_5_0(w[42], w[41], w[2], params->GC_23, params->GC_8, params->GC_22,
      amp[39]);
  FFVS1_2_0(w[28], w[26], w[42], w[2], params->GC_11, params->GC_12, amp[40]); 
  VVS3_5_0(w[43], w[44], w[2], params->GC_26, params->GC_24, amp[41]); 
  VVS1_5_0(w[43], w[45], w[2], params->GC_27, params->GC_25, amp[42]); 
  VVS1_5_0(w[44], w[46], w[2], params->GC_27, params->GC_25, amp[43]); 
  VVS3_4_5_0(w[46], w[45], w[2], params->GC_23, params->GC_8, params->GC_22,
      amp[44]);
  FFVS1_2_0(w[27], w[26], w[46], w[2], params->GC_11, params->GC_12, amp[45]); 
  FFV2_3_0(w[28], w[26], w[47], params->GC_31, params->GC_32, amp[46]); 
  FFV2_3_0(w[27], w[26], w[48], params->GC_31, params->GC_32, amp[47]); 
  VVS3_5_0(w[5], w[16], w[2], params->GC_26, params->GC_24, amp[48]); 
  VVS1_5_0(w[5], w[17], w[2], params->GC_27, params->GC_25, amp[49]); 
  VVS1_5_0(w[16], w[8], w[2], params->GC_27, params->GC_25, amp[50]); 
  VVS3_4_5_0(w[8], w[17], w[2], params->GC_23, params->GC_8, params->GC_22,
      amp[51]);
  FFVS1_2_0(w[1], w[4], w[8], w[2], params->GC_11, params->GC_12, amp[52]); 
  VVS2_4_5_0(w[49], w[50], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[53]);
  FFVS1_0(w[1], w[3], w[49], w[2], params->GC_129, amp[54]); 
  FFV2_3_0(w[1], w[4], w[13], params->GC_31, params->GC_32, amp[55]); 
  FFV2_0(w[1], w[3], w[51], params->GC_42, amp[56]); 
  VVS3_5_0(w[5], w[16], w[2], params->GC_26, params->GC_24, amp[57]); 
  VVS1_5_0(w[5], w[17], w[2], params->GC_27, params->GC_25, amp[58]); 
  VVS1_5_0(w[16], w[8], w[2], params->GC_27, params->GC_25, amp[59]); 
  VVS3_4_5_0(w[8], w[17], w[2], params->GC_23, params->GC_8, params->GC_22,
      amp[60]);
  FFVS1_2_0(w[1], w[4], w[8], w[2], params->GC_11, params->GC_12, amp[61]); 
  VVS2_4_5_0(w[52], w[53], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[62]);
  FFVS1_0(w[1], w[3], w[52], w[2], params->GC_132, amp[63]); 
  FFV2_3_0(w[1], w[4], w[13], params->GC_31, params->GC_32, amp[64]); 
  FFV2_0(w[1], w[3], w[54], params->GC_119, amp[65]); 
  VVS3_5_0(w[5], w[16], w[2], params->GC_26, params->GC_24, amp[66]); 
  VVS1_5_0(w[5], w[17], w[2], params->GC_27, params->GC_25, amp[67]); 
  VVS1_5_0(w[16], w[8], w[2], params->GC_27, params->GC_25, amp[68]); 
  VVS3_4_5_0(w[8], w[17], w[2], params->GC_23, params->GC_8, params->GC_22,
      amp[69]);
  FFVS1_2_0(w[1], w[4], w[8], w[2], params->GC_11, params->GC_12, amp[70]); 
  VVS2_4_5_0(w[55], w[56], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[71]);
  FFVS1_0(w[1], w[3], w[55], w[2], params->GC_133, amp[72]); 
  FFV2_3_0(w[1], w[4], w[13], params->GC_31, params->GC_32, amp[73]); 
  FFV2_0(w[1], w[3], w[57], params->GC_118, amp[74]); 
  VVS3_5_0(w[29], w[40], w[2], params->GC_26, params->GC_24, amp[75]); 
  VVS1_5_0(w[29], w[41], w[2], params->GC_27, params->GC_25, amp[76]); 
  VVS1_5_0(w[40], w[32], w[2], params->GC_27, params->GC_25, amp[77]); 
  VVS3_4_5_0(w[32], w[41], w[2], params->GC_23, params->GC_8, params->GC_22,
      amp[78]);
  FFVS1_2_0(w[28], w[26], w[32], w[2], params->GC_11, params->GC_12, amp[79]); 
  VVS2_4_5_0(w[59], w[58], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[80]);
  FFVS1_0(w[27], w[26], w[58], w[2], params->GC_130, amp[81]); 
  FFV2_3_0(w[28], w[26], w[37], params->GC_31, params->GC_32, amp[82]); 
  FFV2_0(w[27], w[26], w[60], params->GC_42, amp[83]); 
  VVS3_5_0(w[29], w[40], w[2], params->GC_26, params->GC_24, amp[84]); 
  VVS1_5_0(w[29], w[41], w[2], params->GC_27, params->GC_25, amp[85]); 
  VVS1_5_0(w[40], w[32], w[2], params->GC_27, params->GC_25, amp[86]); 
  VVS3_4_5_0(w[32], w[41], w[2], params->GC_23, params->GC_8, params->GC_22,
      amp[87]);
  FFVS1_2_0(w[28], w[26], w[32], w[2], params->GC_11, params->GC_12, amp[88]); 
  VVS2_4_5_0(w[62], w[61], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[89]);
  FFVS1_0(w[27], w[26], w[61], w[2], params->GC_134, amp[90]); 
  FFV2_3_0(w[28], w[26], w[37], params->GC_31, params->GC_32, amp[91]); 
  FFV2_0(w[27], w[26], w[63], params->GC_119, amp[92]); 
  VVS3_5_0(w[29], w[40], w[2], params->GC_26, params->GC_24, amp[93]); 
  VVS1_5_0(w[29], w[41], w[2], params->GC_27, params->GC_25, amp[94]); 
  VVS1_5_0(w[40], w[32], w[2], params->GC_27, params->GC_25, amp[95]); 
  VVS3_4_5_0(w[32], w[41], w[2], params->GC_23, params->GC_8, params->GC_22,
      amp[96]);
  FFVS1_2_0(w[28], w[26], w[32], w[2], params->GC_11, params->GC_12, amp[97]); 
  VVS2_4_5_0(w[65], w[64], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[98]);
  FFVS1_0(w[27], w[26], w[64], w[2], params->GC_131, amp[99]); 
  FFV2_3_0(w[28], w[26], w[37], params->GC_31, params->GC_32, amp[100]); 
  FFV2_0(w[27], w[26], w[66], params->GC_118, amp[101]); 
  FFV2_3_0(w[1], w[4], w[13], params->GC_39, params->GC_40, amp[102]); 
  VVS3_5_0(w[5], w[30], w[2], params->GC_26, params->GC_24, amp[103]); 
  VVS1_5_0(w[5], w[31], w[2], params->GC_27, params->GC_25, amp[104]); 
  VVS1_5_0(w[30], w[8], w[2], params->GC_27, params->GC_25, amp[105]); 
  VVS3_4_5_0(w[8], w[31], w[2], params->GC_23, params->GC_8, params->GC_22,
      amp[106]);
  FFVS1_2_0(w[28], w[26], w[8], w[2], params->GC_19, params->GC_20, amp[107]); 
  FFV2_3_0(w[28], w[26], w[13], params->GC_39, params->GC_40, amp[108]); 
  VVS3_5_0(w[5], w[40], w[2], params->GC_26, params->GC_24, amp[109]); 
  VVS1_5_0(w[5], w[41], w[2], params->GC_27, params->GC_25, amp[110]); 
  VVS1_5_0(w[40], w[8], w[2], params->GC_27, params->GC_25, amp[111]); 
  VVS3_4_5_0(w[8], w[41], w[2], params->GC_23, params->GC_8, params->GC_22,
      amp[112]);
  FFVS1_2_0(w[28], w[26], w[8], w[2], params->GC_11, params->GC_12, amp[113]); 
  FFV2_3_0(w[28], w[26], w[13], params->GC_31, params->GC_32, amp[114]); 
  VVS3_5_0(w[15], w[16], w[2], params->GC_26, params->GC_24, amp[115]); 
  VVS1_5_0(w[15], w[17], w[2], params->GC_27, params->GC_25, amp[116]); 
  VVS1_5_0(w[16], w[18], w[2], params->GC_27, params->GC_25, amp[117]); 
  VVS3_4_5_0(w[18], w[17], w[2], params->GC_23, params->GC_8, params->GC_22,
      amp[118]);
  FFVS1_2_0(w[1], w[4], w[18], w[2], params->GC_11, params->GC_12, amp[119]); 
  FFV2_3_0(w[1], w[4], w[23], params->GC_31, params->GC_32, amp[120]); 
  VVS3_5_0(w[15], w[30], w[2], params->GC_26, params->GC_24, amp[121]); 
  VVS1_5_0(w[15], w[31], w[2], params->GC_27, params->GC_25, amp[122]); 
  VVS1_5_0(w[30], w[18], w[2], params->GC_27, params->GC_25, amp[123]); 
  VVS3_4_5_0(w[18], w[31], w[2], params->GC_23, params->GC_8, params->GC_22,
      amp[124]);
  FFVS1_2_0(w[28], w[26], w[18], w[2], params->GC_19, params->GC_20, amp[125]); 
  FFV2_3_0(w[28], w[26], w[23], params->GC_39, params->GC_40, amp[126]); 
  VVS3_5_0(w[15], w[40], w[2], params->GC_26, params->GC_24, amp[127]); 
  VVS1_5_0(w[15], w[41], w[2], params->GC_27, params->GC_25, amp[128]); 
  VVS1_5_0(w[40], w[18], w[2], params->GC_27, params->GC_25, amp[129]); 
  VVS3_4_5_0(w[18], w[41], w[2], params->GC_23, params->GC_8, params->GC_22,
      amp[130]);
  FFVS1_2_0(w[28], w[26], w[18], w[2], params->GC_11, params->GC_12, amp[131]); 
  FFV2_3_0(w[28], w[26], w[23], params->GC_31, params->GC_32, amp[132]); 
  VVS3_5_0(w[29], w[30], w[2], params->GC_26, params->GC_24, amp[133]); 
  VVS1_5_0(w[29], w[31], w[2], params->GC_27, params->GC_25, amp[134]); 
  VVS1_5_0(w[30], w[32], w[2], params->GC_27, params->GC_25, amp[135]); 
  VVS3_4_5_0(w[32], w[31], w[2], params->GC_23, params->GC_8, params->GC_22,
      amp[136]);
  FFVS1_2_0(w[28], w[26], w[32], w[2], params->GC_19, params->GC_20, amp[137]); 
  FFV2_3_0(w[28], w[26], w[37], params->GC_39, params->GC_40, amp[138]); 
  VVS3_5_0(w[39], w[40], w[2], params->GC_26, params->GC_24, amp[139]); 
  VVS1_5_0(w[39], w[41], w[2], params->GC_27, params->GC_25, amp[140]); 
  VVS1_5_0(w[40], w[42], w[2], params->GC_27, params->GC_25, amp[141]); 
  VVS3_4_5_0(w[42], w[41], w[2], params->GC_23, params->GC_8, params->GC_22,
      amp[142]);
  FFVS1_2_0(w[28], w[26], w[42], w[2], params->GC_11, params->GC_12, amp[143]); 
  FFV2_3_0(w[28], w[26], w[47], params->GC_31, params->GC_32, amp[144]); 
  VVS2_4_5_0(w[52], w[50], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[145]);
  FFVS1_0(w[1], w[3], w[52], w[2], params->GC_129, amp[146]); 
  FFV2_0(w[1], w[3], w[54], params->GC_42, amp[147]); 
  VVS2_4_5_0(w[49], w[56], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[148]);
  FFVS1_0(w[1], w[3], w[49], w[2], params->GC_133, amp[149]); 
  FFV2_0(w[1], w[3], w[51], params->GC_118, amp[150]); 
  VVS2_4_5_0(w[52], w[56], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[151]);
  FFVS1_0(w[1], w[3], w[52], w[2], params->GC_133, amp[152]); 
  FFV2_0(w[1], w[3], w[54], params->GC_118, amp[153]); 
  VVS2_4_5_0(w[49], w[53], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[154]);
  FFVS1_0(w[1], w[3], w[49], w[2], params->GC_132, amp[155]); 
  FFV2_0(w[1], w[3], w[51], params->GC_119, amp[156]); 
  VVS2_4_5_0(w[49], w[50], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[157]);
  FFVS1_0(w[1], w[3], w[49], w[2], params->GC_129, amp[158]); 
  FFV2_0(w[1], w[3], w[51], params->GC_42, amp[159]); 
  VVS2_4_5_0(w[67], w[68], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[160]);
  FFVS1_0(w[28], w[26], w[67], w[2], params->GC_129, amp[161]); 
  FFV2_0(w[28], w[26], w[69], params->GC_42, amp[162]); 
  VVS2_4_5_0(w[67], w[70], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[163]);
  FFVS1_0(w[28], w[26], w[67], w[2], params->GC_132, amp[164]); 
  FFV2_0(w[28], w[26], w[69], params->GC_119, amp[165]); 
  VVS2_4_5_0(w[71], w[68], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[166]);
  FFVS1_0(w[28], w[26], w[71], w[2], params->GC_129, amp[167]); 
  FFV2_0(w[28], w[26], w[72], params->GC_42, amp[168]); 
  VVS2_4_5_0(w[71], w[70], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[169]);
  FFVS1_0(w[28], w[26], w[71], w[2], params->GC_132, amp[170]); 
  FFV2_0(w[28], w[26], w[72], params->GC_119, amp[171]); 
  VVS2_4_5_0(w[67], w[73], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[172]);
  FFVS1_0(w[28], w[26], w[67], w[2], params->GC_133, amp[173]); 
  FFV2_0(w[28], w[26], w[69], params->GC_118, amp[174]); 
  VVS2_4_5_0(w[71], w[73], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[175]);
  FFVS1_0(w[28], w[26], w[71], w[2], params->GC_133, amp[176]); 
  FFV2_0(w[28], w[26], w[72], params->GC_118, amp[177]); 
  VVS2_4_5_0(w[55], w[50], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[178]);
  FFVS1_0(w[1], w[3], w[55], w[2], params->GC_129, amp[179]); 
  FFV2_0(w[1], w[3], w[57], params->GC_42, amp[180]); 
  VVS2_4_5_0(w[55], w[53], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[181]);
  FFVS1_0(w[1], w[3], w[55], w[2], params->GC_132, amp[182]); 
  FFV2_0(w[1], w[3], w[57], params->GC_119, amp[183]); 
  VVS2_4_5_0(w[74], w[68], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[184]);
  FFVS1_0(w[28], w[26], w[74], w[2], params->GC_129, amp[185]); 
  FFV2_0(w[28], w[26], w[75], params->GC_42, amp[186]); 
  VVS2_4_5_0(w[74], w[70], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[187]);
  FFVS1_0(w[28], w[26], w[74], w[2], params->GC_132, amp[188]); 
  FFV2_0(w[28], w[26], w[75], params->GC_119, amp[189]); 
  VVS2_4_5_0(w[74], w[73], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[190]);
  FFVS1_0(w[28], w[26], w[74], w[2], params->GC_133, amp[191]); 
  FFV2_0(w[28], w[26], w[75], params->GC_118, amp[192]); 
  VVS2_4_5_0(w[68], w[67], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[193]);
  FFVS1_0(w[28], w[26], w[67], w[2], params->GC_130, amp[194]); 
  FFV2_0(w[28], w[26], w[76], params->GC_42, amp[195]); 
  VVS2_4_5_0(w[73], w[67], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[196]);
  FFVS1_0(w[28], w[26], w[67], w[2], params->GC_131, amp[197]); 
  FFV2_0(w[28], w[26], w[76], params->GC_118, amp[198]); 
  VVS2_4_5_0(w[68], w[74], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[199]);
  FFVS1_0(w[28], w[26], w[74], w[2], params->GC_130, amp[200]); 
  FFV2_0(w[28], w[26], w[77], params->GC_42, amp[201]); 
  VVS2_4_5_0(w[73], w[74], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[202]);
  FFVS1_0(w[28], w[26], w[74], w[2], params->GC_131, amp[203]); 
  FFV2_0(w[28], w[26], w[77], params->GC_118, amp[204]); 
  VVS2_4_5_0(w[70], w[67], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[205]);
  FFVS1_0(w[28], w[26], w[67], w[2], params->GC_134, amp[206]); 
  FFV2_0(w[28], w[26], w[76], params->GC_119, amp[207]); 
  VVS2_4_5_0(w[70], w[74], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[208]);
  FFVS1_0(w[28], w[26], w[74], w[2], params->GC_134, amp[209]); 
  FFV2_0(w[28], w[26], w[77], params->GC_119, amp[210]); 
  VVS2_4_5_0(w[68], w[71], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[211]);
  FFVS1_0(w[28], w[26], w[71], w[2], params->GC_130, amp[212]); 
  FFV2_0(w[28], w[26], w[78], params->GC_42, amp[213]); 
  VVS2_4_5_0(w[73], w[71], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[214]);
  FFVS1_0(w[28], w[26], w[71], w[2], params->GC_131, amp[215]); 
  FFV2_0(w[28], w[26], w[78], params->GC_118, amp[216]); 
  VVS2_4_5_0(w[70], w[71], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[217]);
  FFVS1_0(w[28], w[26], w[71], w[2], params->GC_134, amp[218]); 
  FFV2_0(w[28], w[26], w[78], params->GC_119, amp[219]); 
  VVS2_4_5_0(w[59], w[61], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[220]);
  FFVS1_0(w[27], w[26], w[61], w[2], params->GC_130, amp[221]); 
  FFV2_0(w[27], w[26], w[63], params->GC_42, amp[222]); 
  VVS2_4_5_0(w[65], w[58], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[223]);
  FFVS1_0(w[27], w[26], w[58], w[2], params->GC_131, amp[224]); 
  FFV2_0(w[27], w[26], w[60], params->GC_118, amp[225]); 
  VVS2_4_5_0(w[65], w[61], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[226]);
  FFVS1_0(w[27], w[26], w[61], w[2], params->GC_131, amp[227]); 
  FFV2_0(w[27], w[26], w[63], params->GC_118, amp[228]); 
  VVS2_4_5_0(w[62], w[58], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[229]);
  FFVS1_0(w[27], w[26], w[58], w[2], params->GC_134, amp[230]); 
  FFV2_0(w[27], w[26], w[60], params->GC_119, amp[231]); 
  VVS2_4_5_0(w[59], w[58], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[232]);
  FFVS1_0(w[27], w[26], w[58], w[2], params->GC_130, amp[233]); 
  FFV2_0(w[27], w[26], w[60], params->GC_42, amp[234]); 
  VVS2_4_5_0(w[59], w[64], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[235]);
  FFVS1_0(w[27], w[26], w[64], w[2], params->GC_130, amp[236]); 
  FFV2_0(w[27], w[26], w[66], params->GC_42, amp[237]); 
  VVS2_4_5_0(w[62], w[64], w[2], params->GC_10, params->GC_7, params->GC_9,
      amp[238]);
  FFVS1_0(w[27], w[26], w[64], w[2], params->GC_134, amp[239]); 
  FFV2_0(w[27], w[26], w[66], params->GC_119, amp[240]); 

}
double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uu_huu() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = -amp[0] - amp[1] - amp[2] - amp[3] - amp[4] - amp[10]; 
  jamp[1] = +amp[5] + amp[6] + amp[7] + amp[8] + amp[9] + amp[11]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_dd_hdd() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = -amp[12] - amp[13] - amp[14] - amp[15] - amp[16] - amp[22]; 
  jamp[1] = +amp[17] + amp[18] + amp[19] + amp[20] + amp[21] + amp[23]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uxux_huxux() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = -amp[24] - amp[25] - amp[26] - amp[27] - amp[28] - amp[34]; 
  jamp[1] = +amp[29] + amp[30] + amp[31] + amp[32] + amp[33] + amp[35]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_dxdx_hdxdx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = -amp[36] - amp[37] - amp[38] - amp[39] - amp[40] - amp[46]; 
  jamp[1] = +amp[41] + amp[42] + amp[43] + amp[44] + amp[45] + amp[47]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ud_hud() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = -amp[48] - amp[49] - amp[50] - amp[51] - amp[52] - amp[55]; 
  jamp[1] = +amp[53] + amp[54] + amp[56]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_us_hus() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = -amp[57] - amp[58] - amp[59] - amp[60] - amp[61] - amp[64]; 
  jamp[1] = +amp[62] + amp[63] + amp[65]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_cd_hcd() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = -amp[66] - amp[67] - amp[68] - amp[69] - amp[70] - amp[73]; 
  jamp[1] = +amp[71] + amp[72] + amp[74]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uxdx_huxdx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = -amp[75] - amp[76] - amp[77] - amp[78] - amp[79] - amp[82]; 
  jamp[1] = +amp[80] + amp[81] + amp[83]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uxsx_huxsx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = -amp[84] - amp[85] - amp[86] - amp[87] - amp[88] - amp[91]; 
  jamp[1] = +amp[89] + amp[90] + amp[92]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_cxdx_hcxdx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = -amp[93] - amp[94] - amp[95] - amp[96] - amp[97] - amp[100]; 
  jamp[1] = +amp[98] + amp[99] + amp[101]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uc_huc() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = -amp[0] - amp[1] - amp[2] - amp[3] - amp[4] - amp[102]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uux_huux() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[103] + amp[104] + amp[105] + amp[106] + amp[107] + amp[108]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_udx_hudx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[109] + amp[110] + amp[111] + amp[112] + amp[113] + amp[114]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ds_hds() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = -amp[115] - amp[116] - amp[117] - amp[118] - amp[119] - amp[120]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_dux_hdux() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[121] + amp[122] + amp[123] + amp[124] + amp[125] + amp[126]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ddx_hddx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[127] + amp[128] + amp[129] + amp[130] + amp[131] + amp[132]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uxcx_huxcx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = -amp[133] - amp[134] - amp[135] - amp[136] - amp[137] - amp[138]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_dxsx_hdxsx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = -amp[139] - amp[140] - amp[141] - amp[142] - amp[143] - amp[144]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ud_hus() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[145] + amp[146] + amp[147]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ud_hcd() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[148] + amp[149] + amp[150]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ud_hcs() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[151] + amp[152] + amp[153]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_us_hud() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[154] + amp[155] + amp[156]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_us_hcd() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[157] + amp[158] + amp[159]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uux_hddx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[160] + amp[161] + amp[162]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uux_hdsx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[163] + amp[164] + amp[165]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uux_hsdx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[166] + amp[167] + amp[168]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uux_hssx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[169] + amp[170] + amp[171]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ucx_hddx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[172] + amp[173] + amp[174]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ucx_hsdx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[175] + amp[176] + amp[177]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_cd_hud() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[178] + amp[179] + amp[180]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_cs_hud() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[181] + amp[182] + amp[183]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_cux_hddx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[184] + amp[185] + amp[186]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_cux_hdsx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[187] + amp[188] + amp[189]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ccx_hddx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[190] + amp[191] + amp[192]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ddx_huux() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[193] + amp[194] + amp[195]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ddx_hucx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[196] + amp[197] + amp[198]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ddx_hcux() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[199] + amp[200] + amp[201]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ddx_hccx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[202] + amp[203] + amp[204]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_dsx_huux() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[205] + amp[206] + amp[207]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_dsx_hcux() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[208] + amp[209] + amp[210]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_sdx_huux() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[211] + amp[212] + amp[213]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_sdx_hucx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[214] + amp[215] + amp[216]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_ssx_huux() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[217] + amp[218] + amp[219]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uxdx_huxsx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[220] + amp[221] + amp[222]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uxdx_hcxdx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[223] + amp[224] + amp[225]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uxdx_hcxsx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[226] + amp[227] + amp[228]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uxsx_huxdx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[229] + amp[230] + amp[231]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_uxsx_hcxdx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[232] + amp[233] + amp[234]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_cxdx_huxdx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[235] + amp[236] + amp[237]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P1_Sigma_HPO_ewk_prod_NLO_uu_huu::matrix_1_cxsx_huxdx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[1]; 
  // The color matrix
  static const double denom[1] = {1}; 
  static const double cf[1][1] = {{9}}; 

  // Calculate color flows
  jamp[0] = +amp[238] + amp[239] + amp[240]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 1; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 1; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}



}

// Register matrix element with MoMEMta
#include <momemta/MatrixElementFactory.h> 
REGISTER_MATRIX_ELEMENT("qqH_hww_ME_HPO_ewk_prod_NLO_P1_Sigma_HPO_ewk_prod_NLO_uu_huu", qqH_hww_ME_HPO_ewk_prod_NLO::P1_Sigma_HPO_ewk_prod_NLO_uu_huu); 

