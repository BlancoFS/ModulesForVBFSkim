// 
// *  This file was automatically generated by MoMEMta-MaGMEE,
// *  A MadGraph Matrix Element Exporter plugin for MoMEMta.
// *
// *  It is subject to MoMEMta-MaGMEE's license and copyright:
// *
// *  Copyright (C) 2016  Universite catholique de Louvain (UCL), Belgium
// *
// *  This program is free software: you can redistribute it and/or modify
// *  it under the terms of the GNU General Public License as published by
// *  the Free Software Foundation, either version 3 of the License, or
// *  (at your option) any later version.
// *
// *  This program is distributed in the hope that it will be useful,
// *  but WITHOUT ANY WARRANTY; without even the implied warranty of
// *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// *  GNU General Public License for more details.
// *
// *  You should have received a copy of the GNU General Public License
// *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
// 

#include <string> 
#include <utility> 
#include <vector> 
#include <map> 

#include <P2_Sigma_sm_gg_auux.h> 
#include <HelAmps_sm.h> 

#include <momemta/ParameterSet.h> 
#include <momemta/SLHAReader.h> 

namespace DY_ME_sm 
{

//==========================================================================
// Class member functions for calculating the matrix elements for
// Process: g g > a u u~ WEIGHTED<=4 @2
// Process: g g > a c c~ WEIGHTED<=4 @2
// Process: g g > a d d~ WEIGHTED<=4 @2
// Process: g g > a s s~ WEIGHTED<=4 @2
// Process: g u > a g u WEIGHTED<=4 @2
// Process: g c > a g c WEIGHTED<=4 @2
// Process: g d > a g d WEIGHTED<=4 @2
// Process: g s > a g s WEIGHTED<=4 @2
// Process: g u~ > a g u~ WEIGHTED<=4 @2
// Process: g c~ > a g c~ WEIGHTED<=4 @2
// Process: g d~ > a g d~ WEIGHTED<=4 @2
// Process: g s~ > a g s~ WEIGHTED<=4 @2
// Process: u u > a u u WEIGHTED<=4 @2
// Process: c c > a c c WEIGHTED<=4 @2
// Process: u u~ > a g g WEIGHTED<=4 @2
// Process: c c~ > a g g WEIGHTED<=4 @2
// Process: u u~ > a u u~ WEIGHTED<=4 @2
// Process: c c~ > a c c~ WEIGHTED<=4 @2
// Process: d d > a d d WEIGHTED<=4 @2
// Process: s s > a s s WEIGHTED<=4 @2
// Process: d d~ > a g g WEIGHTED<=4 @2
// Process: s s~ > a g g WEIGHTED<=4 @2
// Process: d d~ > a d d~ WEIGHTED<=4 @2
// Process: s s~ > a s s~ WEIGHTED<=4 @2
// Process: u~ u~ > a u~ u~ WEIGHTED<=4 @2
// Process: c~ c~ > a c~ c~ WEIGHTED<=4 @2
// Process: d~ d~ > a d~ d~ WEIGHTED<=4 @2
// Process: s~ s~ > a s~ s~ WEIGHTED<=4 @2
// Process: u c > a u c WEIGHTED<=4 @2
// Process: u d > a u d WEIGHTED<=4 @2
// Process: u s > a u s WEIGHTED<=4 @2
// Process: c d > a c d WEIGHTED<=4 @2
// Process: c s > a c s WEIGHTED<=4 @2
// Process: u u~ > a c c~ WEIGHTED<=4 @2
// Process: c c~ > a u u~ WEIGHTED<=4 @2
// Process: u u~ > a d d~ WEIGHTED<=4 @2
// Process: u u~ > a s s~ WEIGHTED<=4 @2
// Process: c c~ > a d d~ WEIGHTED<=4 @2
// Process: c c~ > a s s~ WEIGHTED<=4 @2
// Process: u c~ > a u c~ WEIGHTED<=4 @2
// Process: c u~ > a c u~ WEIGHTED<=4 @2
// Process: u d~ > a u d~ WEIGHTED<=4 @2
// Process: u s~ > a u s~ WEIGHTED<=4 @2
// Process: c d~ > a c d~ WEIGHTED<=4 @2
// Process: c s~ > a c s~ WEIGHTED<=4 @2
// Process: d s > a d s WEIGHTED<=4 @2
// Process: d u~ > a d u~ WEIGHTED<=4 @2
// Process: d c~ > a d c~ WEIGHTED<=4 @2
// Process: s u~ > a s u~ WEIGHTED<=4 @2
// Process: s c~ > a s c~ WEIGHTED<=4 @2
// Process: d d~ > a u u~ WEIGHTED<=4 @2
// Process: d d~ > a c c~ WEIGHTED<=4 @2
// Process: s s~ > a u u~ WEIGHTED<=4 @2
// Process: s s~ > a c c~ WEIGHTED<=4 @2
// Process: d d~ > a s s~ WEIGHTED<=4 @2
// Process: s s~ > a d d~ WEIGHTED<=4 @2
// Process: d s~ > a d s~ WEIGHTED<=4 @2
// Process: s d~ > a s d~ WEIGHTED<=4 @2
// Process: u~ c~ > a u~ c~ WEIGHTED<=4 @2
// Process: u~ d~ > a u~ d~ WEIGHTED<=4 @2
// Process: u~ s~ > a u~ s~ WEIGHTED<=4 @2
// Process: c~ d~ > a c~ d~ WEIGHTED<=4 @2
// Process: c~ s~ > a c~ s~ WEIGHTED<=4 @2
// Process: d~ s~ > a d~ s~ WEIGHTED<=4 @2

//--------------------------------------------------------------------------

// Initialize process.

P2_Sigma_sm_gg_auux::P2_Sigma_sm_gg_auux(const ParameterSet& configuration) 
{

  std::string param_card = configuration.get < std::string > ("card"); 
  params.reset(new Parameters_sm(SLHA::Reader(param_card))); 

  // Set external particle masses for this matrix element
  mME.push_back(std::ref(params->ZERO)); 
  mME.push_back(std::ref(params->ZERO)); 
  mME.push_back(std::ref(params->ZERO)); 
  mME.push_back(std::ref(params->ZERO)); 
  mME.push_back(std::ref(params->ZERO)); 

  mapFinalStates[{22, -2, -2}] = 
  {
    {
      &P2_Sigma_sm_gg_auux::matrix_2_uxux_auxux, 
      false, 
      {
        std::make_pair(-2, -2), std::make_pair(-4, -4)
      }, 
      32, 
      72
    }
  }; 
  mapFinalStates[{22, 21, 2}] = 
  {
    {
      &P2_Sigma_sm_gg_auux::matrix_2_gu_agu, 
      true, 
      {
        std::make_pair(21, 2), std::make_pair(21, 4)
      }, 
      32, 
      96
    }
  }; 
  mapFinalStates[{22, -2, -4}] = 
  {
    {
      &P2_Sigma_sm_gg_auux::matrix_2_uxcx_auxcx, 
      true, 
      {
        std::make_pair(-2, -4)
      }, 
      32, 
      36
    }
  }; 
  mapFinalStates[{22, 1, -1}] = 
  {
    {
      &P2_Sigma_sm_gg_auux::matrix_2_gg_addx, 
      false, 
      {
        std::make_pair(21, 21), std::make_pair(21, 21)
      }, 
      32, 
      256
    }
    , 
    {
      &P2_Sigma_sm_gg_auux::matrix_2_ddx_addx, 
      true, 
      {
        std::make_pair(1, -1), std::make_pair(3, -3)
      }, 
      32, 
      36
    }
    , 
    {
      &P2_Sigma_sm_gg_auux::matrix_2_uux_addx, 
      true, 
      {
        std::make_pair(2, -2), std::make_pair(2, -2), std::make_pair(4, -4),
            std::make_pair(4, -4)
      }, 
      32, 
      36
    }
  }; 
  mapFinalStates[{22, 4, -4}] = 
  {
    {
      &P2_Sigma_sm_gg_auux::matrix_2_uux_accx, 
      true, 
      {
        std::make_pair(2, -2), std::make_pair(4, -4)
      }, 
      32, 
      36
    }
  }; 
  mapFinalStates[{22, 2, 1}] = 
  {
    {
      &P2_Sigma_sm_gg_auux::matrix_2_ud_aud, 
      true, 
      {
        std::make_pair(2, 1), std::make_pair(2, 3), std::make_pair(4, 1),
            std::make_pair(4, 3)
      }, 
      32, 
      36
    }
  }; 
  mapFinalStates[{22, 21, -1}] = 
  {
    {
      &P2_Sigma_sm_gg_auux::matrix_2_gdx_agdx, 
      true, 
      {
        std::make_pair(21, -1), std::make_pair(21, -3)
      }, 
      32, 
      96
    }
  }; 
  mapFinalStates[{22, 2, -2}] = 
  {
    {
      &P2_Sigma_sm_gg_auux::matrix_2_gg_auux, 
      false, 
      {
        std::make_pair(21, 21), std::make_pair(21, 21)
      }, 
      32, 
      256
    }
    , 
    {
      &P2_Sigma_sm_gg_auux::matrix_2_uux_auux, 
      true, 
      {
        std::make_pair(2, -2), std::make_pair(4, -4)
      }, 
      32, 
      36
    }
    , 
    {
      &P2_Sigma_sm_gg_auux::matrix_2_ddx_auux, 
      true, 
      {
        std::make_pair(1, -1), std::make_pair(1, -1), std::make_pair(3, -3),
            std::make_pair(3, -3)
      }, 
      32, 
      36
    }
  }; 
  mapFinalStates[{22, 1, -2}] = 
  {
    {
      &P2_Sigma_sm_gg_auux::matrix_2_dux_adux, 
      true, 
      {
        std::make_pair(1, -2), std::make_pair(1, -4), std::make_pair(3, -2),
            std::make_pair(3, -4)
      }, 
      32, 
      36
    }
  }; 
  mapFinalStates[{22, 1, 1}] = 
  {
    {
      &P2_Sigma_sm_gg_auux::matrix_2_dd_add, 
      false, 
      {
        std::make_pair(1, 1), std::make_pair(3, 3)
      }, 
      32, 
      72
    }
  }; 
  mapFinalStates[{22, 2, -4}] = 
  {
    {
      &P2_Sigma_sm_gg_auux::matrix_2_ucx_aucx, 
      true, 
      {
        std::make_pair(2, -4), std::make_pair(4, -2)
      }, 
      32, 
      36
    }
  }; 
  mapFinalStates[{22, 2, 4}] = 
  {
    {
      &P2_Sigma_sm_gg_auux::matrix_2_uc_auc, 
      true, 
      {
        std::make_pair(2, 4)
      }, 
      32, 
      36
    }
  }; 
  mapFinalStates[{22, 2, 2}] = 
  {
    {
      &P2_Sigma_sm_gg_auux::matrix_2_uu_auu, 
      false, 
      {
        std::make_pair(2, 2), std::make_pair(4, 4)
      }, 
      32, 
      72
    }
  }; 
  mapFinalStates[{22, 21, 1}] = 
  {
    {
      &P2_Sigma_sm_gg_auux::matrix_2_gd_agd, 
      true, 
      {
        std::make_pair(21, 1), std::make_pair(21, 3)
      }, 
      32, 
      96
    }
  }; 
  mapFinalStates[{22, 1, 3}] = 
  {
    {
      &P2_Sigma_sm_gg_auux::matrix_2_ds_ads, 
      true, 
      {
        std::make_pair(1, 3)
      }, 
      32, 
      36
    }
  }; 
  mapFinalStates[{22, -2, -1}] = 
  {
    {
      &P2_Sigma_sm_gg_auux::matrix_2_uxdx_auxdx, 
      true, 
      {
        std::make_pair(-2, -1), std::make_pair(-2, -3), std::make_pair(-4, -1),
            std::make_pair(-4, -3)
      }, 
      32, 
      36
    }
  }; 
  mapFinalStates[{22, -1, -1}] = 
  {
    {
      &P2_Sigma_sm_gg_auux::matrix_2_dxdx_adxdx, 
      false, 
      {
        std::make_pair(-1, -1), std::make_pair(-3, -3)
      }, 
      32, 
      72
    }
  }; 
  mapFinalStates[{22, 2, -1}] = 
  {
    {
      &P2_Sigma_sm_gg_auux::matrix_2_udx_audx, 
      true, 
      {
        std::make_pair(2, -1), std::make_pair(2, -3), std::make_pair(4, -1),
            std::make_pair(4, -3)
      }, 
      32, 
      36
    }
  }; 
  mapFinalStates[{22, 3, -3}] = 
  {
    {
      &P2_Sigma_sm_gg_auux::matrix_2_ddx_assx, 
      true, 
      {
        std::make_pair(1, -1), std::make_pair(3, -3)
      }, 
      32, 
      36
    }
  }; 
  mapFinalStates[{22, 21, -2}] = 
  {
    {
      &P2_Sigma_sm_gg_auux::matrix_2_gux_agux, 
      true, 
      {
        std::make_pair(21, -2), std::make_pair(21, -4)
      }, 
      32, 
      96
    }
  }; 
  mapFinalStates[{22, -1, -3}] = 
  {
    {
      &P2_Sigma_sm_gg_auux::matrix_2_dxsx_adxsx, 
      true, 
      {
        std::make_pair(-1, -3)
      }, 
      32, 
      36
    }
  }; 
  mapFinalStates[{22, 21, 21}] = 
  {
    {
      &P2_Sigma_sm_gg_auux::matrix_2_uux_agg, 
      true, 
      {
        std::make_pair(2, -2), std::make_pair(4, -4)
      }, 
      32, 
      72
    }
    , 
    {
      &P2_Sigma_sm_gg_auux::matrix_2_ddx_agg, 
      true, 
      {
        std::make_pair(1, -1), std::make_pair(3, -3)
      }, 
      32, 
      72
    }
  }; 
  mapFinalStates[{22, 1, -3}] = 
  {
    {
      &P2_Sigma_sm_gg_auux::matrix_2_dsx_adsx, 
      true, 
      {
        std::make_pair(1, -3), std::make_pair(3, -1)
      }, 
      32, 
      36
    }
  }; 

}

void P2_Sigma_sm_gg_auux::resetHelicities() 
{
  for (auto& finalState: mapFinalStates)
  {
    for (auto& subProcess: finalState.second)
    {
      subProcess.resetHelicities(); 
    }
  }
}


//--------------------------------------------------------------------------
// Evaluate |M|^2, return a map of final states

std::map < std::pair < int, int > , double > P2_Sigma_sm_gg_auux::compute(const
    std::pair < std::vector<double> , std::vector<double> > &initialMomenta,
    const std::vector < std::pair < int, std::vector<double> > > &finalState)
{

  // Set initial particle momenta
  momenta[0] = (double * ) (&initialMomenta.first[0]); 
  momenta[1] = (double * ) (&initialMomenta.second[0]); 

  // Suppose final particles are passed in the "correct" order
  std::vector<int> selectedFinalState(5 - 2); 
  for (size_t index = 0; index < (5 - 2); index++ )
  {
    selectedFinalState[index] = finalState[index].first; 
    momenta[index + 2] = (double * ) (&finalState[index].second[0]); 
  }

  // Set the event specific parameters
  params->updateParameters(); 
  params->updateCouplings(); 

  // Initialise result object
  std::map < std::pair < int, int > , double > result; 

  // Define permutation
  int perm[5]; 
  for(int i = 0; i < 5; i++ )
  {
    perm[i] = i; 
  }

  for(auto &me: mapFinalStates[selectedFinalState])
  {

    double me_sum = 0; 
    double me_mirror_sum = 0; 

    for(int ihel = 0; ihel < 32; ihel++ )
    {

      if(me.goodHel[ihel])
      {

        double sum = 0.; 
        calculate_wavefunctions(perm, helicities[ihel]); 
        double meTemp = me.callback( * this); 
        sum += meTemp; 
        me_sum += meTemp/me.denominator; 

        if(me.hasMirrorProcess)
        {
          perm[0] = 1; 
          perm[1] = 0; 
          // Calculate wavefunctions
          calculate_wavefunctions(perm, helicities[ihel]); 
          // Mirror back
          perm[0] = 0; 
          perm[1] = 1; 
          meTemp = me.callback( * this); 
          sum += meTemp; 
          me_mirror_sum += meTemp/me.denominator; 
        }

        if( !sum)
          me.goodHel[ihel] = false; 
      }
    }

    for (auto const &initialState: me.initialStates)
    {
      result[initialState] = me_sum; 
      if (me.hasMirrorProcess)
        result[std::make_pair(initialState.second, initialState.first)] =
            me_mirror_sum;
    }
  }


  return result; 
}

//==========================================================================
// Private class member functions

//--------------------------------------------------------------------------
// Evaluate |M|^2 for each subprocess

void P2_Sigma_sm_gg_auux::calculate_wavefunctions(const int perm[], const int
    hel[])
{
  // Calculate wavefunctions for all processes
  static std::complex<double> w[56][18]; 

  // Calculate all wavefunctions
  vxxxxx(&momenta[perm[0]][0], mME[0], hel[0], -1, w[0]); 
  vxxxxx(&momenta[perm[1]][0], mME[1], hel[1], -1, w[1]); 
  vxxxxx(&momenta[perm[2]][0], mME[2], hel[2], +1, w[2]); 
  oxxxxx(&momenta[perm[3]][0], mME[3], hel[3], +1, w[3]); 
  ixxxxx(&momenta[perm[4]][0], mME[4], hel[4], -1, w[4]); 
  VVV1P0_1(w[0], w[1], params->GC_10, params->ZERO, params->ZERO, w[5]); 
  FFV1_1(w[3], w[2], params->GC_2, params->ZERO, params->ZERO, w[6]); 
  FFV1_2(w[4], w[2], params->GC_2, params->ZERO, params->ZERO, w[7]); 
  FFV1_1(w[3], w[0], params->GC_11, params->ZERO, params->ZERO, w[8]); 
  FFV1_2(w[4], w[1], params->GC_11, params->ZERO, params->ZERO, w[9]); 
  FFV1_2(w[4], w[0], params->GC_11, params->ZERO, params->ZERO, w[10]); 
  FFV1_1(w[3], w[1], params->GC_11, params->ZERO, params->ZERO, w[11]); 
  FFV1_1(w[3], w[2], params->GC_1, params->ZERO, params->ZERO, w[12]); 
  FFV1_2(w[4], w[2], params->GC_1, params->ZERO, params->ZERO, w[13]); 
  ixxxxx(&momenta[perm[1]][0], mME[1], hel[1], +1, w[14]); 
  vxxxxx(&momenta[perm[3]][0], mME[3], hel[3], +1, w[15]); 
  oxxxxx(&momenta[perm[4]][0], mME[4], hel[4], +1, w[16]); 
  VVV1P0_1(w[0], w[15], params->GC_10, params->ZERO, params->ZERO, w[17]); 
  FFV1_1(w[16], w[2], params->GC_2, params->ZERO, params->ZERO, w[18]); 
  FFV1_2(w[14], w[2], params->GC_2, params->ZERO, params->ZERO, w[19]); 
  FFV1_1(w[16], w[0], params->GC_11, params->ZERO, params->ZERO, w[20]); 
  FFV1_2(w[14], w[15], params->GC_11, params->ZERO, params->ZERO, w[21]); 
  FFV1_2(w[14], w[0], params->GC_11, params->ZERO, params->ZERO, w[22]); 
  FFV1_1(w[16], w[15], params->GC_11, params->ZERO, params->ZERO, w[23]); 
  FFV1_1(w[16], w[2], params->GC_1, params->ZERO, params->ZERO, w[24]); 
  FFV1_2(w[14], w[2], params->GC_1, params->ZERO, params->ZERO, w[25]); 
  oxxxxx(&momenta[perm[1]][0], mME[1], hel[1], -1, w[26]); 
  FFV1_1(w[26], w[2], params->GC_2, params->ZERO, params->ZERO, w[27]); 
  FFV1_1(w[26], w[0], params->GC_11, params->ZERO, params->ZERO, w[28]); 
  FFV1_2(w[4], w[15], params->GC_11, params->ZERO, params->ZERO, w[29]); 
  FFV1_1(w[26], w[15], params->GC_11, params->ZERO, params->ZERO, w[30]); 
  FFV1_1(w[26], w[2], params->GC_1, params->ZERO, params->ZERO, w[31]); 
  ixxxxx(&momenta[perm[0]][0], mME[0], hel[0], +1, w[32]); 
  FFV1_2(w[32], w[2], params->GC_2, params->ZERO, params->ZERO, w[33]); 
  FFV1P0_3(w[14], w[3], params->GC_11, params->ZERO, params->ZERO, w[34]); 
  FFV1P0_3(w[14], w[16], params->GC_11, params->ZERO, params->ZERO, w[35]); 
  FFV1P0_3(w[32], w[3], params->GC_11, params->ZERO, params->ZERO, w[36]); 
  FFV1P0_3(w[32], w[16], params->GC_11, params->ZERO, params->ZERO, w[37]); 
  vxxxxx(&momenta[perm[4]][0], mME[4], hel[4], +1, w[38]); 
  VVV1P0_1(w[15], w[38], params->GC_10, params->ZERO, params->ZERO, w[39]); 
  FFV1_2(w[32], w[38], params->GC_11, params->ZERO, params->ZERO, w[40]); 
  FFV1_2(w[32], w[15], params->GC_11, params->ZERO, params->ZERO, w[41]); 
  FFV1_1(w[26], w[38], params->GC_11, params->ZERO, params->ZERO, w[42]); 
  FFV1P0_3(w[4], w[26], params->GC_11, params->ZERO, params->ZERO, w[43]); 
  FFV1P0_3(w[4], w[3], params->GC_11, params->ZERO, params->ZERO, w[44]); 
  FFV1P0_3(w[32], w[26], params->GC_11, params->ZERO, params->ZERO, w[45]); 
  FFV1_2(w[32], w[2], params->GC_1, params->ZERO, params->ZERO, w[46]); 
  oxxxxx(&momenta[perm[0]][0], mME[0], hel[0], -1, w[47]); 
  ixxxxx(&momenta[perm[3]][0], mME[3], hel[3], -1, w[48]); 
  FFV1_2(w[48], w[2], params->GC_2, params->ZERO, params->ZERO, w[49]); 
  FFV1P0_3(w[4], w[47], params->GC_11, params->ZERO, params->ZERO, w[50]); 
  FFV1P0_3(w[48], w[47], params->GC_11, params->ZERO, params->ZERO, w[51]); 
  FFV1P0_3(w[48], w[26], params->GC_11, params->ZERO, params->ZERO, w[52]); 
  FFV1_1(w[47], w[2], params->GC_2, params->ZERO, params->ZERO, w[53]); 
  FFV1_2(w[48], w[2], params->GC_1, params->ZERO, params->ZERO, w[54]); 
  FFV1_1(w[47], w[2], params->GC_1, params->ZERO, params->ZERO, w[55]); 

  // Calculate all amplitudes
  // Amplitude(s) for diagram number 0
  FFV1_0(w[4], w[6], w[5], params->GC_11, amp[0]); 
  FFV1_0(w[7], w[3], w[5], params->GC_11, amp[1]); 
  FFV1_0(w[9], w[8], w[2], params->GC_2, amp[2]); 
  FFV1_0(w[7], w[8], w[1], params->GC_11, amp[3]); 
  FFV1_0(w[10], w[11], w[2], params->GC_2, amp[4]); 
  FFV1_0(w[10], w[6], w[1], params->GC_11, amp[5]); 
  FFV1_0(w[7], w[11], w[0], params->GC_11, amp[6]); 
  FFV1_0(w[9], w[6], w[0], params->GC_11, amp[7]); 
  FFV1_0(w[4], w[12], w[5], params->GC_11, amp[8]); 
  FFV1_0(w[13], w[3], w[5], params->GC_11, amp[9]); 
  FFV1_0(w[9], w[8], w[2], params->GC_1, amp[10]); 
  FFV1_0(w[13], w[8], w[1], params->GC_11, amp[11]); 
  FFV1_0(w[10], w[11], w[2], params->GC_1, amp[12]); 
  FFV1_0(w[10], w[12], w[1], params->GC_11, amp[13]); 
  FFV1_0(w[13], w[11], w[0], params->GC_11, amp[14]); 
  FFV1_0(w[9], w[12], w[0], params->GC_11, amp[15]); 
  FFV1_0(w[14], w[18], w[17], params->GC_11, amp[16]); 
  FFV1_0(w[19], w[16], w[17], params->GC_11, amp[17]); 
  FFV1_0(w[21], w[20], w[2], params->GC_2, amp[18]); 
  FFV1_0(w[19], w[20], w[15], params->GC_11, amp[19]); 
  FFV1_0(w[22], w[23], w[2], params->GC_2, amp[20]); 
  FFV1_0(w[22], w[18], w[15], params->GC_11, amp[21]); 
  FFV1_0(w[19], w[23], w[0], params->GC_11, amp[22]); 
  FFV1_0(w[21], w[18], w[0], params->GC_11, amp[23]); 
  FFV1_0(w[14], w[24], w[17], params->GC_11, amp[24]); 
  FFV1_0(w[25], w[16], w[17], params->GC_11, amp[25]); 
  FFV1_0(w[21], w[20], w[2], params->GC_1, amp[26]); 
  FFV1_0(w[25], w[20], w[15], params->GC_11, amp[27]); 
  FFV1_0(w[22], w[23], w[2], params->GC_1, amp[28]); 
  FFV1_0(w[22], w[24], w[15], params->GC_11, amp[29]); 
  FFV1_0(w[25], w[23], w[0], params->GC_11, amp[30]); 
  FFV1_0(w[21], w[24], w[0], params->GC_11, amp[31]); 
  FFV1_0(w[4], w[27], w[17], params->GC_11, amp[32]); 
  FFV1_0(w[7], w[26], w[17], params->GC_11, amp[33]); 
  FFV1_0(w[29], w[28], w[2], params->GC_2, amp[34]); 
  FFV1_0(w[7], w[28], w[15], params->GC_11, amp[35]); 
  FFV1_0(w[10], w[30], w[2], params->GC_2, amp[36]); 
  FFV1_0(w[10], w[27], w[15], params->GC_11, amp[37]); 
  FFV1_0(w[7], w[30], w[0], params->GC_11, amp[38]); 
  FFV1_0(w[29], w[27], w[0], params->GC_11, amp[39]); 
  FFV1_0(w[4], w[31], w[17], params->GC_11, amp[40]); 
  FFV1_0(w[13], w[26], w[17], params->GC_11, amp[41]); 
  FFV1_0(w[29], w[28], w[2], params->GC_1, amp[42]); 
  FFV1_0(w[13], w[28], w[15], params->GC_11, amp[43]); 
  FFV1_0(w[10], w[30], w[2], params->GC_1, amp[44]); 
  FFV1_0(w[10], w[31], w[15], params->GC_11, amp[45]); 
  FFV1_0(w[13], w[30], w[0], params->GC_11, amp[46]); 
  FFV1_0(w[29], w[31], w[0], params->GC_11, amp[47]); 
  FFV1_0(w[33], w[16], w[34], params->GC_11, amp[48]); 
  FFV1_0(w[33], w[3], w[35], params->GC_11, amp[49]); 
  FFV1_0(w[19], w[16], w[36], params->GC_11, amp[50]); 
  FFV1_0(w[14], w[18], w[36], params->GC_11, amp[51]); 
  FFV1_0(w[19], w[3], w[37], params->GC_11, amp[52]); 
  FFV1_0(w[14], w[6], w[37], params->GC_11, amp[53]); 
  FFV1_0(w[32], w[18], w[34], params->GC_11, amp[54]); 
  FFV1_0(w[32], w[6], w[35], params->GC_11, amp[55]); 
  FFV1_0(w[32], w[27], w[39], params->GC_11, amp[56]); 
  FFV1_0(w[33], w[26], w[39], params->GC_11, amp[57]); 
  FFV1_0(w[40], w[30], w[2], params->GC_2, amp[58]); 
  FFV1_0(w[33], w[30], w[38], params->GC_11, amp[59]); 
  FFV1_0(w[41], w[42], w[2], params->GC_2, amp[60]); 
  FFV1_0(w[41], w[27], w[38], params->GC_11, amp[61]); 
  FFV1_0(w[33], w[42], w[15], params->GC_11, amp[62]); 
  FFV1_0(w[40], w[27], w[15], params->GC_11, amp[63]); 
  FFV1_0(w[33], w[3], w[43], params->GC_11, amp[64]); 
  FFV1_0(w[33], w[26], w[44], params->GC_11, amp[65]); 
  FFV1_0(w[7], w[3], w[45], params->GC_11, amp[66]); 
  FFV1_0(w[4], w[6], w[45], params->GC_11, amp[67]); 
  FFV1_0(w[7], w[26], w[36], params->GC_11, amp[68]); 
  FFV1_0(w[4], w[27], w[36], params->GC_11, amp[69]); 
  FFV1_0(w[32], w[6], w[43], params->GC_11, amp[70]); 
  FFV1_0(w[32], w[27], w[44], params->GC_11, amp[71]); 
  FFV1_0(w[46], w[16], w[34], params->GC_11, amp[72]); 
  FFV1_0(w[46], w[3], w[35], params->GC_11, amp[73]); 
  FFV1_0(w[25], w[16], w[36], params->GC_11, amp[74]); 
  FFV1_0(w[14], w[24], w[36], params->GC_11, amp[75]); 
  FFV1_0(w[25], w[3], w[37], params->GC_11, amp[76]); 
  FFV1_0(w[14], w[12], w[37], params->GC_11, amp[77]); 
  FFV1_0(w[32], w[24], w[34], params->GC_11, amp[78]); 
  FFV1_0(w[32], w[12], w[35], params->GC_11, amp[79]); 
  FFV1_0(w[32], w[31], w[39], params->GC_11, amp[80]); 
  FFV1_0(w[46], w[26], w[39], params->GC_11, amp[81]); 
  FFV1_0(w[40], w[30], w[2], params->GC_1, amp[82]); 
  FFV1_0(w[46], w[30], w[38], params->GC_11, amp[83]); 
  FFV1_0(w[41], w[42], w[2], params->GC_1, amp[84]); 
  FFV1_0(w[41], w[31], w[38], params->GC_11, amp[85]); 
  FFV1_0(w[46], w[42], w[15], params->GC_11, amp[86]); 
  FFV1_0(w[40], w[31], w[15], params->GC_11, amp[87]); 
  FFV1_0(w[46], w[3], w[43], params->GC_11, amp[88]); 
  FFV1_0(w[46], w[26], w[44], params->GC_11, amp[89]); 
  FFV1_0(w[13], w[3], w[45], params->GC_11, amp[90]); 
  FFV1_0(w[4], w[12], w[45], params->GC_11, amp[91]); 
  FFV1_0(w[13], w[26], w[36], params->GC_11, amp[92]); 
  FFV1_0(w[4], w[31], w[36], params->GC_11, amp[93]); 
  FFV1_0(w[32], w[12], w[43], params->GC_11, amp[94]); 
  FFV1_0(w[32], w[31], w[44], params->GC_11, amp[95]); 
  FFV1_0(w[49], w[26], w[50], params->GC_11, amp[96]); 
  FFV1_0(w[49], w[47], w[43], params->GC_11, amp[97]); 
  FFV1_0(w[7], w[26], w[51], params->GC_11, amp[98]); 
  FFV1_0(w[4], w[27], w[51], params->GC_11, amp[99]); 
  FFV1_0(w[7], w[47], w[52], params->GC_11, amp[100]); 
  FFV1_0(w[4], w[53], w[52], params->GC_11, amp[101]); 
  FFV1_0(w[48], w[27], w[50], params->GC_11, amp[102]); 
  FFV1_0(w[48], w[53], w[43], params->GC_11, amp[103]); 
  FFV1_0(w[54], w[26], w[50], params->GC_11, amp[104]); 
  FFV1_0(w[54], w[47], w[43], params->GC_11, amp[105]); 
  FFV1_0(w[13], w[26], w[51], params->GC_11, amp[106]); 
  FFV1_0(w[4], w[31], w[51], params->GC_11, amp[107]); 
  FFV1_0(w[13], w[47], w[52], params->GC_11, amp[108]); 
  FFV1_0(w[4], w[55], w[52], params->GC_11, amp[109]); 
  FFV1_0(w[48], w[31], w[50], params->GC_11, amp[110]); 
  FFV1_0(w[48], w[55], w[43], params->GC_11, amp[111]); 
  FFV1_0(w[33], w[3], w[35], params->GC_11, amp[112]); 
  FFV1_0(w[19], w[16], w[36], params->GC_11, amp[113]); 
  FFV1_0(w[14], w[18], w[36], params->GC_11, amp[114]); 
  FFV1_0(w[32], w[6], w[35], params->GC_11, amp[115]); 
  FFV1_0(w[33], w[3], w[35], params->GC_11, amp[116]); 
  FFV1_0(w[25], w[16], w[36], params->GC_11, amp[117]); 
  FFV1_0(w[14], w[24], w[36], params->GC_11, amp[118]); 
  FFV1_0(w[32], w[6], w[35], params->GC_11, amp[119]); 
  FFV1_0(w[33], w[26], w[44], params->GC_11, amp[120]); 
  FFV1_0(w[7], w[3], w[45], params->GC_11, amp[121]); 
  FFV1_0(w[4], w[6], w[45], params->GC_11, amp[122]); 
  FFV1_0(w[32], w[27], w[44], params->GC_11, amp[123]); 
  FFV1_0(w[33], w[26], w[44], params->GC_11, amp[124]); 
  FFV1_0(w[13], w[3], w[45], params->GC_11, amp[125]); 
  FFV1_0(w[4], w[12], w[45], params->GC_11, amp[126]); 
  FFV1_0(w[32], w[27], w[44], params->GC_11, amp[127]); 
  FFV1_0(w[33], w[3], w[43], params->GC_11, amp[128]); 
  FFV1_0(w[7], w[26], w[36], params->GC_11, amp[129]); 
  FFV1_0(w[4], w[27], w[36], params->GC_11, amp[130]); 
  FFV1_0(w[32], w[6], w[43], params->GC_11, amp[131]); 
  FFV1_0(w[33], w[3], w[43], params->GC_11, amp[132]); 
  FFV1_0(w[13], w[26], w[36], params->GC_11, amp[133]); 
  FFV1_0(w[4], w[31], w[36], params->GC_11, amp[134]); 
  FFV1_0(w[32], w[6], w[43], params->GC_11, amp[135]); 
  FFV1_0(w[46], w[3], w[35], params->GC_11, amp[136]); 
  FFV1_0(w[25], w[16], w[36], params->GC_11, amp[137]); 
  FFV1_0(w[14], w[24], w[36], params->GC_11, amp[138]); 
  FFV1_0(w[32], w[12], w[35], params->GC_11, amp[139]); 
  FFV1_0(w[7], w[26], w[36], params->GC_11, amp[140]); 
  FFV1_0(w[46], w[3], w[43], params->GC_11, amp[141]); 
  FFV1_0(w[32], w[12], w[43], params->GC_11, amp[142]); 
  FFV1_0(w[4], w[27], w[36], params->GC_11, amp[143]); 
  FFV1_0(w[7], w[3], w[45], params->GC_11, amp[144]); 
  FFV1_0(w[46], w[26], w[44], params->GC_11, amp[145]); 
  FFV1_0(w[32], w[31], w[44], params->GC_11, amp[146]); 
  FFV1_0(w[4], w[6], w[45], params->GC_11, amp[147]); 
  FFV1_0(w[46], w[26], w[44], params->GC_11, amp[148]); 
  FFV1_0(w[13], w[3], w[45], params->GC_11, amp[149]); 
  FFV1_0(w[4], w[12], w[45], params->GC_11, amp[150]); 
  FFV1_0(w[32], w[31], w[44], params->GC_11, amp[151]); 
  FFV1_0(w[46], w[3], w[43], params->GC_11, amp[152]); 
  FFV1_0(w[13], w[26], w[36], params->GC_11, amp[153]); 
  FFV1_0(w[4], w[31], w[36], params->GC_11, amp[154]); 
  FFV1_0(w[32], w[12], w[43], params->GC_11, amp[155]); 
  FFV1_0(w[49], w[47], w[43], params->GC_11, amp[156]); 
  FFV1_0(w[7], w[26], w[51], params->GC_11, amp[157]); 
  FFV1_0(w[4], w[27], w[51], params->GC_11, amp[158]); 
  FFV1_0(w[48], w[53], w[43], params->GC_11, amp[159]); 
  FFV1_0(w[49], w[47], w[43], params->GC_11, amp[160]); 
  FFV1_0(w[13], w[26], w[51], params->GC_11, amp[161]); 
  FFV1_0(w[4], w[31], w[51], params->GC_11, amp[162]); 
  FFV1_0(w[48], w[53], w[43], params->GC_11, amp[163]); 
  FFV1_0(w[54], w[47], w[43], params->GC_11, amp[164]); 
  FFV1_0(w[13], w[26], w[51], params->GC_11, amp[165]); 
  FFV1_0(w[4], w[31], w[51], params->GC_11, amp[166]); 
  FFV1_0(w[48], w[55], w[43], params->GC_11, amp[167]); 

}
double P2_Sigma_sm_gg_auux::matrix_2_gg_auux() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {3, 3}; 
  static const double cf[2][2] = {{16, -2}, {-2, 16}}; 

  // Calculate color flows
  static const std::complex<double> cI(0., 1.); 
  jamp[0] = +cI * amp[0] + cI * amp[1] - amp[2] - amp[3] - amp[7]; 
  jamp[1] = -cI * amp[0] - cI * amp[1] - amp[4] - amp[5] - amp[6]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_gg_addx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {3, 3}; 
  static const double cf[2][2] = {{16, -2}, {-2, 16}}; 

  // Calculate color flows
  static const std::complex<double> cI(0., 1.); 
  jamp[0] = +cI * amp[8] + cI * amp[9] - amp[10] - amp[11] - amp[15]; 
  jamp[1] = -cI * amp[8] - cI * amp[9] - amp[12] - amp[13] - amp[14]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_gu_agu() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {3, 3}; 
  static const double cf[2][2] = {{16, -2}, {-2, 16}}; 

  // Calculate color flows
  static const std::complex<double> cI(0., 1.); 
  jamp[0] = -cI * amp[16] - cI * amp[17] + amp[18] + amp[19] + amp[23]; 
  jamp[1] = +cI * amp[16] + cI * amp[17] + amp[20] + amp[21] + amp[22]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_gd_agd() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {3, 3}; 
  static const double cf[2][2] = {{16, -2}, {-2, 16}}; 

  // Calculate color flows
  static const std::complex<double> cI(0., 1.); 
  jamp[0] = -cI * amp[24] - cI * amp[25] + amp[26] + amp[27] + amp[31]; 
  jamp[1] = +cI * amp[24] + cI * amp[25] + amp[28] + amp[29] + amp[30]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_gux_agux() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {3, 3}; 
  static const double cf[2][2] = {{16, -2}, {-2, 16}}; 

  // Calculate color flows
  static const std::complex<double> cI(0., 1.); 
  jamp[0] = +cI * amp[32] + cI * amp[33] - amp[34] - amp[35] - amp[39]; 
  jamp[1] = -cI * amp[32] - cI * amp[33] - amp[36] - amp[37] - amp[38]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_gdx_agdx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {3, 3}; 
  static const double cf[2][2] = {{16, -2}, {-2, 16}}; 

  // Calculate color flows
  static const std::complex<double> cI(0., 1.); 
  jamp[0] = +cI * amp[40] + cI * amp[41] - amp[42] - amp[43] - amp[47]; 
  jamp[1] = -cI * amp[40] - cI * amp[41] - amp[44] - amp[45] - amp[46]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_uu_auu() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = +1./2. * (+amp[48] + 1./3. * amp[49] + 1./3. * amp[50] + 1./3. *
      amp[51] + amp[52] + amp[53] + amp[54] + 1./3. * amp[55]);
  jamp[1] = +1./2. * (-1./3. * amp[48] - amp[49] - amp[50] - amp[51] - 1./3. *
      amp[52] - 1./3. * amp[53] - 1./3. * amp[54] - amp[55]);

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_uux_agg() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {3, 3}; 
  static const double cf[2][2] = {{16, -2}, {-2, 16}}; 

  // Calculate color flows
  static const std::complex<double> cI(0., 1.); 
  jamp[0] = -cI * amp[56] - cI * amp[57] + amp[58] + amp[59] + amp[63]; 
  jamp[1] = +cI * amp[56] + cI * amp[57] + amp[60] + amp[61] + amp[62]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_uux_auux() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = +1./2. * (+amp[64] + 1./3. * amp[65] + 1./3. * amp[66] + 1./3. *
      amp[67] + amp[68] + amp[69] + amp[70] + 1./3. * amp[71]);
  jamp[1] = +1./2. * (-1./3. * amp[64] - amp[65] - amp[66] - amp[67] - 1./3. *
      amp[68] - 1./3. * amp[69] - 1./3. * amp[70] - amp[71]);

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_dd_add() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = +1./2. * (+amp[72] + 1./3. * amp[73] + 1./3. * amp[74] + 1./3. *
      amp[75] + amp[76] + amp[77] + amp[78] + 1./3. * amp[79]);
  jamp[1] = +1./2. * (-1./3. * amp[72] - amp[73] - amp[74] - amp[75] - 1./3. *
      amp[76] - 1./3. * amp[77] - 1./3. * amp[78] - amp[79]);

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_ddx_agg() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {3, 3}; 
  static const double cf[2][2] = {{16, -2}, {-2, 16}}; 

  // Calculate color flows
  static const std::complex<double> cI(0., 1.); 
  jamp[0] = -cI * amp[80] - cI * amp[81] + amp[82] + amp[83] + amp[87]; 
  jamp[1] = +cI * amp[80] + cI * amp[81] + amp[84] + amp[85] + amp[86]; 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_ddx_addx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = +1./2. * (+amp[88] + 1./3. * amp[89] + 1./3. * amp[90] + 1./3. *
      amp[91] + amp[92] + amp[93] + amp[94] + 1./3. * amp[95]);
  jamp[1] = +1./2. * (-1./3. * amp[88] - amp[89] - amp[90] - amp[91] - 1./3. *
      amp[92] - 1./3. * amp[93] - 1./3. * amp[94] - amp[95]);

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_uxux_auxux() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = +1./2. * (+amp[96] + 1./3. * amp[97] + 1./3. * amp[98] + 1./3. *
      amp[99] + amp[100] + amp[101] + amp[102] + 1./3. * amp[103]);
  jamp[1] = +1./2. * (-1./3. * amp[96] - amp[97] - amp[98] - amp[99] - 1./3. *
      amp[100] - 1./3. * amp[101] - 1./3. * amp[102] - amp[103]);

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_dxdx_adxdx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = +1./2. * (+amp[104] + 1./3. * amp[105] + 1./3. * amp[106] + 1./3. *
      amp[107] + amp[108] + amp[109] + amp[110] + 1./3. * amp[111]);
  jamp[1] = +1./2. * (-1./3. * amp[104] - amp[105] - amp[106] - amp[107] -
      1./3. * amp[108] - 1./3. * amp[109] - 1./3. * amp[110] - amp[111]);

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_uc_auc() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = +1./2. * (+1./3. * amp[112] + 1./3. * amp[113] + 1./3. * amp[114] +
      1./3. * amp[115]);
  jamp[1] = +1./2. * (-amp[112] - amp[113] - amp[114] - amp[115]); 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_ud_aud() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = +1./2. * (+1./3. * amp[116] + 1./3. * amp[117] + 1./3. * amp[118] +
      1./3. * amp[119]);
  jamp[1] = +1./2. * (-amp[116] - amp[117] - amp[118] - amp[119]); 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_uux_accx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = +1./2. * (+1./3. * amp[120] + 1./3. * amp[121] + 1./3. * amp[122] +
      1./3. * amp[123]);
  jamp[1] = +1./2. * (-amp[120] - amp[121] - amp[122] - amp[123]); 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_uux_addx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = +1./2. * (+1./3. * amp[124] + 1./3. * amp[125] + 1./3. * amp[126] +
      1./3. * amp[127]);
  jamp[1] = +1./2. * (-amp[124] - amp[125] - amp[126] - amp[127]); 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_ucx_aucx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = +1./2. * (+amp[128] + amp[129] + amp[130] + amp[131]); 
  jamp[1] = +1./2. * (-1./3. * amp[128] - 1./3. * amp[129] - 1./3. * amp[130] -
      1./3. * amp[131]);

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_udx_audx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = +1./2. * (+amp[132] + amp[133] + amp[134] + amp[135]); 
  jamp[1] = +1./2. * (-1./3. * amp[132] - 1./3. * amp[133] - 1./3. * amp[134] -
      1./3. * amp[135]);

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_ds_ads() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = +1./2. * (+1./3. * amp[136] + 1./3. * amp[137] + 1./3. * amp[138] +
      1./3. * amp[139]);
  jamp[1] = +1./2. * (-amp[136] - amp[137] - amp[138] - amp[139]); 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_dux_adux() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = +1./2. * (+amp[140] + amp[141] + amp[142] + amp[143]); 
  jamp[1] = +1./2. * (-1./3. * amp[140] - 1./3. * amp[141] - 1./3. * amp[142] -
      1./3. * amp[143]);

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_ddx_auux() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = +1./2. * (+1./3. * amp[144] + 1./3. * amp[145] + 1./3. * amp[146] +
      1./3. * amp[147]);
  jamp[1] = +1./2. * (-amp[144] - amp[145] - amp[146] - amp[147]); 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_ddx_assx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = +1./2. * (+1./3. * amp[148] + 1./3. * amp[149] + 1./3. * amp[150] +
      1./3. * amp[151]);
  jamp[1] = +1./2. * (-amp[148] - amp[149] - amp[150] - amp[151]); 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_dsx_adsx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = +1./2. * (+amp[152] + amp[153] + amp[154] + amp[155]); 
  jamp[1] = +1./2. * (-1./3. * amp[152] - 1./3. * amp[153] - 1./3. * amp[154] -
      1./3. * amp[155]);

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_uxcx_auxcx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = +1./2. * (+1./3. * amp[156] + 1./3. * amp[157] + 1./3. * amp[158] +
      1./3. * amp[159]);
  jamp[1] = +1./2. * (-amp[156] - amp[157] - amp[158] - amp[159]); 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_uxdx_auxdx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = +1./2. * (+1./3. * amp[160] + 1./3. * amp[161] + 1./3. * amp[162] +
      1./3. * amp[163]);
  jamp[1] = +1./2. * (-amp[160] - amp[161] - amp[162] - amp[163]); 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}

double P2_Sigma_sm_gg_auux::matrix_2_dxsx_adxsx() 
{

  static std::complex<double> ztemp; 
  static std::complex<double> jamp[2]; 
  // The color matrix
  static const double denom[2] = {1, 1}; 
  static const double cf[2][2] = {{9, 3}, {3, 9}}; 

  // Calculate color flows
  jamp[0] = +1./2. * (+1./3. * amp[164] + 1./3. * amp[165] + 1./3. * amp[166] +
      1./3. * amp[167]);
  jamp[1] = +1./2. * (-amp[164] - amp[165] - amp[166] - amp[167]); 

  // Sum and square the color flows to get the matrix element
  double matrix = 0; 
  for(int i = 0; i < 2; i++ )
  {
    ztemp = 0.; 
    for(int j = 0; j < 2; j++ )
      ztemp = ztemp + cf[i][j] * jamp[j]; 
    matrix = matrix + real(ztemp * conj(jamp[i]))/denom[i]; 
  }

  return matrix; 
}



}

// Register matrix element with MoMEMta
#include <momemta/MatrixElementFactory.h> 
REGISTER_MATRIX_ELEMENT("DY_ME_sm_P2_Sigma_sm_gg_auux",
    DY_ME_sm::P2_Sigma_sm_gg_auux);

